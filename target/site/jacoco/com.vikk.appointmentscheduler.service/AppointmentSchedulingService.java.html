<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AppointmentSchedulingService.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Appointment Scheduling Optimizer</a> &gt; <a href="index.source.html" class="el_package">com.vikk.appointmentscheduler.service</a> &gt; <span class="el_source">AppointmentSchedulingService.java</span></div><h1>AppointmentSchedulingService.java</h1><pre class="source lang-java linenums">package com.vikk.appointmentscheduler.service;

import java.util.ArrayList;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

import com.vikk.appointmentscheduler.algorithm.ConstraintSatisfactionAlgorithm;
import com.vikk.appointmentscheduler.algorithm.GeneticAlgorithm;
import com.vikk.appointmentscheduler.algorithm.SchedulingAlgorithm;
import com.vikk.appointmentscheduler.algorithm.SimulatedAnnealingAlgorithm;
import com.vikk.appointmentscheduler.model.Appointment;
import com.vikk.appointmentscheduler.model.Resource;
import com.vikk.appointmentscheduler.model.Schedule;
import com.vikk.appointmentscheduler.util.MathUtils;

/**
 * Main service for appointment scheduling optimization.
 * Orchestrates different algorithms and provides a unified interface.
 */
public class AppointmentSchedulingService {
    
    private final List&lt;Appointment&gt; appointments;
    private final List&lt;Resource&gt; resources;
    private final Map&lt;String, SchedulingAlgorithm&gt; algorithms;
    
<span class="fc" id="L30">    public AppointmentSchedulingService(List&lt;Appointment&gt; appointments, List&lt;Resource&gt; resources) {</span>
<span class="fc" id="L31">        this.appointments = new ArrayList&lt;&gt;(appointments);</span>
<span class="fc" id="L32">        this.resources = new ArrayList&lt;&gt;(resources);</span>
<span class="fc" id="L33">        this.algorithms = new HashMap&lt;&gt;();</span>
<span class="fc" id="L34">        initializeAlgorithms();</span>
<span class="fc" id="L35">    }</span>
    
    /**
     * Initializes available scheduling algorithms.
     */
    private void initializeAlgorithms() {
<span class="fc" id="L41">        algorithms.put(&quot;CSP&quot;, new ConstraintSatisfactionAlgorithm(appointments, resources));</span>
<span class="fc" id="L42">        algorithms.put(&quot;GA&quot;, new GeneticAlgorithm(appointments, resources));</span>
<span class="fc" id="L43">        algorithms.put(&quot;SA&quot;, new SimulatedAnnealingAlgorithm(appointments, resources));</span>
<span class="fc" id="L44">    }</span>
    
    /**
     * Optimizes schedule using the specified algorithm.
     * 
     * @param algorithmName name of the algorithm to use
     * @return optimized schedule
     */
    public Schedule optimizeSchedule(String algorithmName) {
<span class="fc" id="L53">        SchedulingAlgorithm algorithm = algorithms.get(algorithmName);</span>
<span class="fc bfc" id="L54" title="All 2 branches covered.">        if (algorithm == null) {</span>
<span class="fc" id="L55">            throw new IllegalArgumentException(&quot;Unknown algorithm: &quot; + algorithmName);</span>
        }
        
<span class="fc" id="L58">        return algorithm.optimize();</span>
    }
    
    /**
     * Optimizes schedule using all available algorithms and returns the best result.
     * 
     * @return best schedule found across all algorithms
     */
    public Schedule optimizeScheduleWithAllAlgorithms() {
<span class="fc" id="L67">        List&lt;Schedule&gt; results = new ArrayList&lt;&gt;();</span>
        
<span class="fc bfc" id="L69" title="All 2 branches covered.">        for (Map.Entry&lt;String, SchedulingAlgorithm&gt; entry : algorithms.entrySet()) {</span>
            try {
<span class="fc" id="L71">                Schedule schedule = entry.getValue().optimize();</span>
<span class="fc" id="L72">                schedule.setId(entry.getKey() + &quot;_&quot; + System.currentTimeMillis());</span>
<span class="fc" id="L73">                results.add(schedule);</span>
<span class="nc" id="L74">            } catch (Exception e) {</span>
<span class="nc" id="L75">                System.err.println(&quot;Error running algorithm &quot; + entry.getKey() + &quot;: &quot; + e.getMessage());</span>
<span class="fc" id="L76">            }</span>
<span class="fc" id="L77">        }</span>
        
<span class="pc bpc" id="L79" title="1 of 2 branches missed.">        if (results.isEmpty()) {</span>
<span class="nc" id="L80">            throw new RuntimeException(&quot;All algorithms failed to produce a schedule&quot;);</span>
        }
        
        // Return the schedule with the highest efficiency score
<span class="fc" id="L84">        return results.stream()</span>
<span class="fc" id="L85">                .max(Comparator.comparing(Schedule::calculateEfficiencyScore))</span>
<span class="fc" id="L86">                .orElse(results.get(0));</span>
    }
    
    /**
     * Compares performance of all algorithms.
     * 
     * @return map of algorithm names to their results
     */
    public Map&lt;String, AlgorithmComparisonResult&gt; compareAlgorithms() {
<span class="fc" id="L95">        Map&lt;String, AlgorithmComparisonResult&gt; results = new HashMap&lt;&gt;();</span>
        
<span class="fc bfc" id="L97" title="All 2 branches covered.">        for (Map.Entry&lt;String, SchedulingAlgorithm&gt; entry : algorithms.entrySet()) {</span>
            try {
<span class="fc" id="L99">                long startTime = System.currentTimeMillis();</span>
<span class="fc" id="L100">                Schedule schedule = entry.getValue().optimize();</span>
<span class="fc" id="L101">                long executionTime = System.currentTimeMillis() - startTime;</span>
                
<span class="fc" id="L103">                AlgorithmComparisonResult result = new AlgorithmComparisonResult(</span>
<span class="fc" id="L104">                    entry.getKey(),</span>
                    schedule,
                    executionTime,
<span class="fc" id="L107">                    entry.getValue().getBacktrackCount(),</span>
<span class="fc" id="L108">                    schedule.calculateEfficiencyScore(),</span>
<span class="fc" id="L109">                    schedule.getTotalCost(),</span>
<span class="fc" id="L110">                    schedule.getConflictCount()</span>
                );
                
<span class="fc" id="L113">                results.put(entry.getKey(), result);</span>
<span class="nc" id="L114">            } catch (Exception e) {</span>
<span class="nc" id="L115">                System.err.println(&quot;Error running algorithm &quot; + entry.getKey() + &quot;: &quot; + e.getMessage());</span>
<span class="fc" id="L116">            }</span>
<span class="fc" id="L117">        }</span>
        
<span class="fc" id="L119">        return results;</span>
    }
    
    /**
     * Validates a schedule for conflicts and constraints.
     * 
     * @param schedule schedule to validate
     * @return validation result
     */
    public ScheduleValidationResult validateSchedule(Schedule schedule) {
<span class="nc" id="L129">        List&lt;String&gt; errors = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L130">        List&lt;String&gt; warnings = new ArrayList&lt;&gt;();</span>
        
        // Check for time conflicts
<span class="nc bnc" id="L133" title="All 2 branches missed.">        for (int i = 0; i &lt; schedule.getAppointments().size(); i++) {</span>
<span class="nc" id="L134">            Appointment apt1 = schedule.getAppointments().get(i);</span>
<span class="nc bnc" id="L135" title="All 2 branches missed.">            for (int j = i + 1; j &lt; schedule.getAppointments().size(); j++) {</span>
<span class="nc" id="L136">                Appointment apt2 = schedule.getAppointments().get(j);</span>
                
<span class="nc bnc" id="L138" title="All 2 branches missed.">                if (apt1.conflictsWith(apt2)) {</span>
<span class="nc" id="L139">                    String resource1 = schedule.getResourceForAppointment(apt1.getId());</span>
<span class="nc" id="L140">                    String resource2 = schedule.getResourceForAppointment(apt2.getId());</span>
                    
<span class="nc bnc" id="L142" title="All 4 branches missed.">                    if (resource1 != null &amp;&amp; resource1.equals(resource2)) {</span>
<span class="nc" id="L143">                        errors.add(&quot;Time conflict between &quot; + apt1.getId() + &quot; and &quot; + apt2.getId() + </span>
                                 &quot; on resource &quot; + resource1);
                    }
                }
            }
        }
        
        // Check for unassigned appointments
<span class="nc bnc" id="L151" title="All 2 branches missed.">        for (String unassignedId : schedule.getUnassignedAppointments()) {</span>
<span class="nc" id="L152">            warnings.add(&quot;Appointment &quot; + unassignedId + &quot; is not assigned to any resource&quot;);</span>
<span class="nc" id="L153">        }</span>
        
        // Check resource availability
<span class="nc bnc" id="L156" title="All 2 branches missed.">        for (Appointment appointment : schedule.getAppointments()) {</span>
<span class="nc" id="L157">            String resourceId = schedule.getResourceForAppointment(appointment.getId());</span>
<span class="nc bnc" id="L158" title="All 2 branches missed.">            if (resourceId != null) {</span>
<span class="nc" id="L159">                Resource resource = findResourceById(resourceId);</span>
<span class="nc bnc" id="L160" title="All 2 branches missed.">                if (resource != null) {</span>
<span class="nc bnc" id="L161" title="All 2 branches missed.">                    if (!resource.isAvailableAt(appointment.getStartTime(), appointment.getDuration())) {</span>
<span class="nc" id="L162">                        errors.add(&quot;Appointment &quot; + appointment.getId() + &quot; scheduled outside resource &quot; + </span>
                                 resourceId + &quot; availability&quot;);
                    }
                    
<span class="nc bnc" id="L166" title="All 2 branches missed.">                    if (!resource.hasRequiredCapabilities(appointment.getRequiredCapabilities())) {</span>
<span class="nc" id="L167">                        errors.add(&quot;Resource &quot; + resourceId + &quot; does not have required capabilities for &quot; + </span>
<span class="nc" id="L168">                                 appointment.getId());</span>
                    }
                }
            }
<span class="nc" id="L172">        }</span>
        
<span class="nc" id="L174">        return new ScheduleValidationResult(errors, warnings);</span>
    }
    
    /**
     * Generates a report comparing multiple schedules.
     * 
     * @param schedules schedules to compare
     * @return comparison report
     */
    public ScheduleComparisonReport generateComparisonReport(List&lt;Schedule&gt; schedules) {
<span class="nc bnc" id="L184" title="All 2 branches missed.">        if (schedules.isEmpty()) {</span>
<span class="nc" id="L185">            throw new IllegalArgumentException(&quot;Cannot compare empty schedule list&quot;);</span>
        }
        
<span class="nc" id="L188">        ScheduleComparisonReport report = new ScheduleComparisonReport();</span>
        
        // Calculate statistics
<span class="nc" id="L191">        List&lt;Double&gt; efficiencyScores = schedules.stream()</span>
<span class="nc" id="L192">                .map(Schedule::calculateEfficiencyScore)</span>
<span class="nc" id="L193">                .collect(Collectors.toList());</span>
        
<span class="nc" id="L195">        List&lt;Double&gt; totalCosts = schedules.stream()</span>
<span class="nc" id="L196">                .map(Schedule::getTotalCost)</span>
<span class="nc" id="L197">                .collect(Collectors.toList());</span>
        
<span class="nc" id="L199">        List&lt;Integer&gt; conflictCounts = schedules.stream()</span>
<span class="nc" id="L200">                .map(Schedule::getConflictCount)</span>
<span class="nc" id="L201">                .collect(Collectors.toList());</span>
        
        // Find best and worst
<span class="nc" id="L204">        Schedule bestSchedule = schedules.stream()</span>
<span class="nc" id="L205">                .max(Comparator.comparing(Schedule::calculateEfficiencyScore))</span>
<span class="nc" id="L206">                .orElse(schedules.get(0));</span>
        
<span class="nc" id="L208">        Schedule worstSchedule = schedules.stream()</span>
<span class="nc" id="L209">                .min(Comparator.comparing(Schedule::calculateEfficiencyScore))</span>
<span class="nc" id="L210">                .orElse(schedules.get(0));</span>
        
        // Calculate statistics
<span class="nc" id="L213">        report.setBestSchedule(bestSchedule);</span>
<span class="nc" id="L214">        report.setWorstSchedule(worstSchedule);</span>
<span class="nc" id="L215">        report.setAverageEfficiencyScore(MathUtils.mean(efficiencyScores));</span>
<span class="nc" id="L216">        report.setEfficiencyScoreStdDev(MathUtils.standardDeviation(efficiencyScores));</span>
<span class="nc" id="L217">        report.setAverageCost(MathUtils.mean(totalCosts));</span>
<span class="nc" id="L218">        report.setAverageConflictCount(MathUtils.mean(conflictCounts.stream()</span>
<span class="nc" id="L219">                .map(Integer::doubleValue)</span>
<span class="nc" id="L220">                .collect(Collectors.toList())));</span>
        
<span class="nc" id="L222">        return report;</span>
    }
    
    /**
     * Adds a new appointment to the system.
     * 
     * @param appointment appointment to add
     */
    public void addAppointment(Appointment appointment) {
<span class="nc" id="L231">        appointments.add(appointment);</span>
        // Reinitialize algorithms with new appointment
<span class="nc" id="L233">        initializeAlgorithms();</span>
<span class="nc" id="L234">    }</span>
    
    /**
     * Removes an appointment from the system.
     * 
     * @param appointmentId ID of appointment to remove
     */
    public void removeAppointment(String appointmentId) {
<span class="nc" id="L242">        appointments.removeIf(apt -&gt; apt.getId().equals(appointmentId));</span>
        // Reinitialize algorithms without the appointment
<span class="nc" id="L244">        initializeAlgorithms();</span>
<span class="nc" id="L245">    }</span>
    
    /**
     * Adds a new resource to the system.
     * 
     * @param resource resource to add
     */
    public void addResource(Resource resource) {
<span class="nc" id="L253">        resources.add(resource);</span>
        // Reinitialize algorithms with new resource
<span class="nc" id="L255">        initializeAlgorithms();</span>
<span class="nc" id="L256">    }</span>
    
    /**
     * Removes a resource from the system.
     * 
     * @param resourceId ID of resource to remove
     */
    public void removeResource(String resourceId) {
<span class="nc" id="L264">        resources.removeIf(res -&gt; res.getId().equals(resourceId));</span>
        // Reinitialize algorithms without the resource
<span class="nc" id="L266">        initializeAlgorithms();</span>
<span class="nc" id="L267">    }</span>
    
    /**
     * Gets all available algorithms.
     * 
     * @return set of algorithm names
     */
    public Set&lt;String&gt; getAvailableAlgorithms() {
<span class="fc" id="L275">        return algorithms.keySet();</span>
    }

    public List&lt;SchedulingAlgorithm&gt; getRegisteredAlgorithms() {
<span class="fc" id="L279">        return new ArrayList&lt;&gt;(algorithms.values());</span>
    }
    
    /**
     * Gets all appointments.
     * 
     * @return list of appointments
     */
    public List&lt;Appointment&gt; getAppointments() {
<span class="fc" id="L288">        return new ArrayList&lt;&gt;(appointments);</span>
    }
    
    /**
     * Gets all resources.
     * 
     * @return list of resources
     */
    public List&lt;Resource&gt; getResources() {
<span class="fc" id="L297">        return new ArrayList&lt;&gt;(resources);</span>
    }
    
    // Helper methods
    private Resource findResourceById(String id) {
<span class="nc" id="L302">        return resources.stream()</span>
<span class="nc" id="L303">                .filter(res -&gt; res.getId().equals(id))</span>
<span class="nc" id="L304">                .findFirst()</span>
<span class="nc" id="L305">                .orElse(null);</span>
    }
    
    /**
     * Result of algorithm comparison.
     */
    public static class AlgorithmComparisonResult {
        private final String algorithmName;
        private final Schedule schedule;
        private final long executionTime;
        private final int iterations;
        private final double efficiencyScore;
        private final double totalCost;
        private final int conflictCount;
        
        public AlgorithmComparisonResult(String algorithmName, Schedule schedule, 
                                      long executionTime, int iterations, 
<span class="fc" id="L322">                                      double efficiencyScore, double totalCost, int conflictCount) {</span>
<span class="fc" id="L323">            this.algorithmName = algorithmName;</span>
<span class="fc" id="L324">            this.schedule = schedule;</span>
<span class="fc" id="L325">            this.executionTime = executionTime;</span>
<span class="fc" id="L326">            this.iterations = iterations;</span>
<span class="fc" id="L327">            this.efficiencyScore = efficiencyScore;</span>
<span class="fc" id="L328">            this.totalCost = totalCost;</span>
<span class="fc" id="L329">            this.conflictCount = conflictCount;</span>
<span class="fc" id="L330">        }</span>
        
        // Getters
<span class="fc" id="L333">        public String getAlgorithmName() { return algorithmName; }</span>
<span class="fc" id="L334">        public Schedule getSchedule() { return schedule; }</span>
<span class="fc" id="L335">        public long getExecutionTime() { return executionTime; }</span>
<span class="fc" id="L336">        public int getIterations() { return iterations; }</span>
<span class="nc" id="L337">        public double getEfficiencyScore() { return efficiencyScore; }</span>
<span class="nc" id="L338">        public double getTotalCost() { return totalCost; }</span>
<span class="nc" id="L339">        public int getConflictCount() { return conflictCount; }</span>
    }
    
    /**
     * Result of schedule validation.
     */
    public static class ScheduleValidationResult {
        private final List&lt;String&gt; errors;
        private final List&lt;String&gt; warnings;
        
<span class="nc" id="L349">        public ScheduleValidationResult(List&lt;String&gt; errors, List&lt;String&gt; warnings) {</span>
<span class="nc" id="L350">            this.errors = new ArrayList&lt;&gt;(errors);</span>
<span class="nc" id="L351">            this.warnings = new ArrayList&lt;&gt;(warnings);</span>
<span class="nc" id="L352">        }</span>
        
<span class="nc" id="L354">        public List&lt;String&gt; getErrors() { return errors; }</span>
<span class="nc" id="L355">        public List&lt;String&gt; getWarnings() { return warnings; }</span>
<span class="nc" id="L356">        public boolean isValid() { return errors.isEmpty(); }</span>
<span class="nc bnc" id="L357" title="All 2 branches missed.">        public boolean hasWarnings() { return !warnings.isEmpty(); }</span>
    }
    
    /**
     * Report comparing multiple schedules.
     */
<span class="nc" id="L363">    public static class ScheduleComparisonReport {</span>
        private Schedule bestSchedule;
        private Schedule worstSchedule;
        private double averageEfficiencyScore;
        private double efficiencyScoreStdDev;
        private double averageCost;
        private double averageConflictCount;
        
        // Getters and setters
<span class="nc" id="L372">        public Schedule getBestSchedule() { return bestSchedule; }</span>
<span class="nc" id="L373">        public void setBestSchedule(Schedule bestSchedule) { this.bestSchedule = bestSchedule; }</span>
        
<span class="nc" id="L375">        public Schedule getWorstSchedule() { return worstSchedule; }</span>
<span class="nc" id="L376">        public void setWorstSchedule(Schedule worstSchedule) { this.worstSchedule = worstSchedule; }</span>
        
<span class="nc" id="L378">        public double getAverageEfficiencyScore() { return averageEfficiencyScore; }</span>
        public void setAverageEfficiencyScore(double averageEfficiencyScore) { 
<span class="nc" id="L380">            this.averageEfficiencyScore = averageEfficiencyScore; </span>
<span class="nc" id="L381">        }</span>
        
<span class="nc" id="L383">        public double getEfficiencyScoreStdDev() { return efficiencyScoreStdDev; }</span>
        public void setEfficiencyScoreStdDev(double efficiencyScoreStdDev) { 
<span class="nc" id="L385">            this.efficiencyScoreStdDev = efficiencyScoreStdDev; </span>
<span class="nc" id="L386">        }</span>
        
<span class="nc" id="L388">        public double getAverageCost() { return averageCost; }</span>
<span class="nc" id="L389">        public void setAverageCost(double averageCost) { this.averageCost = averageCost; }</span>
        
<span class="nc" id="L391">        public double getAverageConflictCount() { return averageConflictCount; }</span>
        public void setAverageConflictCount(double averageConflictCount) { 
<span class="nc" id="L393">            this.averageConflictCount = averageConflictCount; </span>
<span class="nc" id="L394">        }</span>
    }
}

</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>