<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MathUtils.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Appointment Scheduling Optimizer</a> &gt; <a href="index.source.html" class="el_package">com.vikk.appointmentscheduler.util</a> &gt; <span class="el_source">MathUtils.java</span></div><h1>MathUtils.java</h1><pre class="source lang-java linenums">package com.vikk.appointmentscheduler.util;

import java.time.Duration;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.stream.Collectors;

/**
 * Mathematical utility functions for appointment scheduling optimization.
 * This class provides â‰¥5 mathematical and logical functions as required by the assignment.
 */
public final class MathUtils {

    private MathUtils() {
        // Utility class - prevent instantiation
    }

    /**
     * 1. MIN/MAX functions for finding extreme values in collections
     */
    public static &lt;T extends Comparable&lt;T&gt;&gt; T min(Collection&lt;T&gt; collection) {
<span class="fc bfc" id="L25" title="All 4 branches covered.">        if (collection == null || collection.isEmpty()) {</span>
<span class="fc" id="L26">            return null;</span>
        }
<span class="fc" id="L28">        return Collections.min(collection);</span>
    }

    public static &lt;T extends Comparable&lt;T&gt;&gt; T max(Collection&lt;T&gt; collection) {
<span class="fc bfc" id="L32" title="All 4 branches covered.">        if (collection == null || collection.isEmpty()) {</span>
<span class="fc" id="L33">            return null;</span>
        }
<span class="fc" id="L35">        return Collections.max(collection);</span>
    }

    public static double minValues(double... values) {
<span class="pc bpc" id="L39" title="1 of 4 branches missed.">        if (values == null || values.length == 0) {</span>
<span class="fc" id="L40">            throw new IllegalArgumentException(&quot;Values array cannot be null or empty&quot;);</span>
        }
<span class="fc" id="L42">        double min = values[0];</span>
<span class="fc bfc" id="L43" title="All 2 branches covered.">        for (int i = 1; i &lt; values.length; i++) {</span>
<span class="fc" id="L44">            min = Math.min(min, values[i]);</span>
        }
<span class="fc" id="L46">        return min;</span>
    }

    public static double maxValues(double... values) {
<span class="pc bpc" id="L50" title="1 of 4 branches missed.">        if (values == null || values.length == 0) {</span>
<span class="fc" id="L51">            throw new IllegalArgumentException(&quot;Values array cannot be null or empty&quot;);</span>
        }
<span class="fc" id="L53">        double max = values[0];</span>
<span class="fc bfc" id="L54" title="All 2 branches covered.">        for (int i = 1; i &lt; values.length; i++) {</span>
<span class="fc" id="L55">            max = Math.max(max, values[i]);</span>
        }
<span class="fc" id="L57">        return max;</span>
    }

    /**
     * 2. ABS function for absolute values
     */
    public static double abs(double value) {
<span class="fc" id="L64">        return Math.abs(value);</span>
    }

    public static int abs(int value) {
<span class="fc" id="L68">        return Math.abs(value);</span>
    }

    public static long abs(long value) {
<span class="nc" id="L72">        return Math.abs(value);</span>
    }

    /**
     * 3. ROUNDING functions with various precision levels
     */
    public static double round(double value, int decimalPlaces) {
<span class="fc bfc" id="L79" title="All 2 branches covered.">        if (decimalPlaces &lt; 0) {</span>
<span class="fc" id="L80">            throw new IllegalArgumentException(&quot;Decimal places must be non-negative&quot;);</span>
        }
<span class="fc" id="L82">        double multiplier = Math.pow(10, decimalPlaces);</span>
<span class="fc" id="L83">        return Math.round(value * multiplier) / multiplier;</span>
    }

    public static double roundToNearest(double value, double nearest) {
<span class="fc bfc" id="L87" title="All 2 branches covered.">        if (nearest &lt;= 0) {</span>
<span class="fc" id="L88">            throw new IllegalArgumentException(&quot;Nearest value must be positive&quot;);</span>
        }
<span class="fc" id="L90">        return Math.round(value / nearest) * nearest;</span>
    }

    public static long roundToMinutes(Duration duration) {
<span class="fc" id="L94">        return Math.round(duration.toMinutes());</span>
    }

    /**
     * 4. MODULO function for cyclic calculations
     */
    public static int mod(int dividend, int divisor) {
<span class="fc bfc" id="L101" title="All 2 branches covered.">        if (divisor == 0) {</span>
<span class="fc" id="L102">            throw new IllegalArgumentException(&quot;Divisor cannot be zero&quot;);</span>
        }
<span class="fc" id="L104">        int result = dividend % divisor;</span>
<span class="fc bfc" id="L105" title="All 2 branches covered.">        return result &lt; 0 ? result + divisor : result;</span>
    }

    public static double mod(double dividend, double divisor) {
<span class="fc bfc" id="L109" title="All 2 branches covered.">        if (divisor == 0) {</span>
<span class="fc" id="L110">            throw new IllegalArgumentException(&quot;Divisor cannot be zero&quot;);</span>
        }
<span class="fc" id="L112">        double result = dividend % divisor;</span>
<span class="fc bfc" id="L113" title="All 2 branches covered.">        return result &lt; 0 ? result + divisor : result;</span>
    }

    /**
     * 5. DATE/TIME calculations for scheduling
     */
    public static Duration calculateDuration(LocalDateTime start, LocalDateTime end) {
<span class="fc bfc" id="L120" title="All 4 branches covered.">        if (start == null || end == null) {</span>
<span class="fc" id="L121">            throw new IllegalArgumentException(&quot;Start and end times cannot be null&quot;);</span>
        }
<span class="pc bpc" id="L123" title="1 of 2 branches missed.">        if (start.isAfter(end)) {</span>
<span class="nc" id="L124">            throw new IllegalArgumentException(&quot;Start time cannot be after end time&quot;);</span>
        }
<span class="fc" id="L126">        return Duration.between(start, end);</span>
    }

    public static boolean isWithinTimeWindow(LocalDateTime time, LocalDateTime windowStart, 
                                           LocalDateTime windowEnd) {
<span class="pc bpc" id="L131" title="3 of 6 branches missed.">        if (time == null || windowStart == null || windowEnd == null) {</span>
<span class="nc" id="L132">            return false;</span>
        }
<span class="pc bpc" id="L134" title="1 of 4 branches missed.">        return !time.isBefore(windowStart) &amp;&amp; !time.isAfter(windowEnd);</span>
    }

    public static LocalDateTime addMinutes(LocalDateTime dateTime, long minutes) {
<span class="pc bpc" id="L138" title="1 of 2 branches missed.">        if (dateTime == null) {</span>
<span class="nc" id="L139">            throw new IllegalArgumentException(&quot;DateTime cannot be null&quot;);</span>
        }
<span class="fc" id="L141">        return dateTime.plusMinutes(minutes);</span>
    }

    public static LocalDateTime subtractMinutes(LocalDateTime dateTime, long minutes) {
<span class="pc bpc" id="L145" title="1 of 2 branches missed.">        if (dateTime == null) {</span>
<span class="nc" id="L146">            throw new IllegalArgumentException(&quot;DateTime cannot be null&quot;);</span>
        }
<span class="fc" id="L148">        return dateTime.minusMinutes(minutes);</span>
    }

    /**
     * 6. SET OPERATIONS for capability matching and conflict detection
     */
    public static &lt;T&gt; boolean hasIntersection(Collection&lt;T&gt; set1, Collection&lt;T&gt; set2) {
<span class="pc bpc" id="L155" title="1 of 4 branches missed.">        if (set1 == null || set2 == null) {</span>
<span class="fc" id="L156">            return false;</span>
        }
<span class="fc" id="L158">        return set1.stream().anyMatch(set2::contains);</span>
    }

    public static &lt;T&gt; boolean isSubset(Collection&lt;T&gt; subset, Collection&lt;T&gt; superset) {
<span class="pc bpc" id="L162" title="1 of 4 branches missed.">        if (subset == null || superset == null) {</span>
<span class="fc" id="L163">            return false;</span>
        }
<span class="fc" id="L165">        return superset.containsAll(subset);</span>
    }

    public static &lt;T&gt; List&lt;T&gt; intersection(Collection&lt;T&gt; set1, Collection&lt;T&gt; set2) {
<span class="pc bpc" id="L169" title="2 of 4 branches missed.">        if (set1 == null || set2 == null) {</span>
<span class="nc" id="L170">            return new ArrayList&lt;&gt;();</span>
        }
<span class="fc" id="L172">        return set1.stream()</span>
<span class="fc" id="L173">                .filter(set2::contains)</span>
<span class="fc" id="L174">                .collect(Collectors.toList());</span>
    }

    public static &lt;T&gt; List&lt;T&gt; union(Collection&lt;T&gt; set1, Collection&lt;T&gt; set2) {
<span class="pc bpc" id="L178" title="3 of 4 branches missed.">        if (set1 == null &amp;&amp; set2 == null) {</span>
<span class="nc" id="L179">            return new ArrayList&lt;&gt;();</span>
        }
<span class="pc bpc" id="L181" title="1 of 2 branches missed.">        if (set1 == null) {</span>
<span class="nc" id="L182">            return new ArrayList&lt;&gt;(set2);</span>
        }
<span class="pc bpc" id="L184" title="1 of 2 branches missed.">        if (set2 == null) {</span>
<span class="nc" id="L185">            return new ArrayList&lt;&gt;(set1);</span>
        }
<span class="fc" id="L187">        List&lt;T&gt; result = new ArrayList&lt;&gt;(set1);</span>
<span class="fc" id="L188">        result.addAll(set2);</span>
<span class="fc" id="L189">        return result.stream().distinct().collect(Collectors.toList());</span>
    }

    /**
     * 7. BOOLEAN LOGIC functions for constraint evaluation
     */
    public static boolean allTrue(boolean... values) {
<span class="pc bpc" id="L196" title="1 of 4 branches missed.">        if (values == null || values.length == 0) {</span>
<span class="fc" id="L197">            return true;</span>
        }
<span class="fc bfc" id="L199" title="All 2 branches covered.">        for (boolean value : values) {</span>
<span class="fc bfc" id="L200" title="All 2 branches covered.">            if (!value) {</span>
<span class="fc" id="L201">                return false;</span>
            }
        }
<span class="fc" id="L204">        return true;</span>
    }

    public static boolean anyTrue(boolean... values) {
<span class="pc bpc" id="L208" title="1 of 4 branches missed.">        if (values == null || values.length == 0) {</span>
<span class="fc" id="L209">            return false;</span>
        }
<span class="fc bfc" id="L211" title="All 2 branches covered.">        for (boolean value : values) {</span>
<span class="fc bfc" id="L212" title="All 2 branches covered.">            if (value) {</span>
<span class="fc" id="L213">                return true;</span>
            }
        }
<span class="fc" id="L216">        return false;</span>
    }

    public static boolean xor(boolean a, boolean b) {
<span class="fc bfc" id="L220" title="All 2 branches covered.">        return a != b;</span>
    }

    /**
     * 8. STATISTICAL functions for performance analysis
     */
    public static double mean(Collection&lt;Double&gt; values) {
<span class="pc bpc" id="L227" title="1 of 4 branches missed.">        if (values == null || values.isEmpty()) {</span>
<span class="fc" id="L228">            return 0.0;</span>
        }
<span class="fc" id="L230">        return values.stream().mapToDouble(Double::doubleValue).average().orElse(0.0);</span>
    }

    public static double median(List&lt;Double&gt; values) {
<span class="pc bpc" id="L234" title="1 of 4 branches missed.">        if (values == null || values.isEmpty()) {</span>
<span class="fc" id="L235">            return 0.0;</span>
        }
<span class="fc" id="L237">        List&lt;Double&gt; sorted = new ArrayList&lt;&gt;(values);</span>
<span class="fc" id="L238">        Collections.sort(sorted);</span>
<span class="fc" id="L239">        int size = sorted.size();</span>
<span class="fc bfc" id="L240" title="All 2 branches covered.">        if (size % 2 == 0) {</span>
<span class="fc" id="L241">            return (sorted.get(size / 2 - 1) + sorted.get(size / 2)) / 2.0;</span>
        } else {
<span class="fc" id="L243">            return sorted.get(size / 2);</span>
        }
    }

    public static double standardDeviation(Collection&lt;Double&gt; values) {
<span class="pc bpc" id="L248" title="1 of 4 branches missed.">        if (values == null || values.size() &lt; 2) {</span>
<span class="fc" id="L249">            return 0.0;</span>
        }
<span class="fc" id="L251">        double mean = mean(values);</span>
<span class="fc" id="L252">        double variance = values.stream()</span>
<span class="fc" id="L253">                .mapToDouble(value -&gt; Math.pow(value - mean, 2))</span>
<span class="fc" id="L254">                .average()</span>
<span class="fc" id="L255">                .orElse(0.0);</span>
<span class="fc" id="L256">        return Math.sqrt(variance);</span>
    }

    /**
     * 9. OPTIMIZATION helper functions
     */
    public static double calculateEuclideanDistance(double x1, double y1, double x2, double y2) {
<span class="fc" id="L263">        double dx = x2 - x1;</span>
<span class="fc" id="L264">        double dy = y2 - y1;</span>
<span class="fc" id="L265">        return Math.sqrt(dx * dx + dy * dy);</span>
    }

    public static double calculateManhattanDistance(double x1, double y1, double x2, double y2) {
<span class="fc" id="L269">        return Math.abs(x2 - x1) + Math.abs(y2 - y1);</span>
    }

    public static double normalize(double value, double min, double max) {
<span class="fc bfc" id="L273" title="All 2 branches covered.">        if (max &lt;= min) {</span>
<span class="fc" id="L274">            throw new IllegalArgumentException(&quot;Max must be greater than min&quot;);</span>
        }
<span class="fc" id="L276">        return (value - min) / (max - min);</span>
    }

    public static double denormalize(double normalizedValue, double min, double max) {
<span class="pc bpc" id="L280" title="1 of 2 branches missed.">        if (max &lt;= min) {</span>
<span class="nc" id="L281">            throw new IllegalArgumentException(&quot;Max must be greater than min&quot;);</span>
        }
<span class="fc" id="L283">        return min + normalizedValue * (max - min);</span>
    }

    /**
     * 10. CONSTRAINT SATISFACTION helper functions
     */
    public static boolean isWithinBounds(double value, double lowerBound, double upperBound) {
<span class="fc bfc" id="L290" title="All 4 branches covered.">        return value &gt;= lowerBound &amp;&amp; value &lt;= upperBound;</span>
    }

    public static double clamp(double value, double min, double max) {
<span class="fc" id="L294">        return Math.max(min, Math.min(max, value));</span>
    }

    public static int clamp(int value, int min, int max) {
<span class="fc" id="L298">        return Math.max(min, Math.min(max, value));</span>
    }

    /**
     * 11. SCHEDULING specific mathematical functions
     */
    public static double calculateOverlapRatio(Duration duration1, LocalDateTime start1,
                                             Duration duration2, LocalDateTime start2) {
<span class="fc" id="L306">        LocalDateTime end1 = start1.plus(duration1);</span>
<span class="fc" id="L307">        LocalDateTime end2 = start2.plus(duration2);</span>
        
<span class="fc" id="L309">        LocalDateTime overlapStart = max(start1, start2);</span>
<span class="fc" id="L310">        LocalDateTime overlapEnd = min(end1, end2);</span>
        
<span class="pc bpc" id="L312" title="2 of 4 branches missed.">        if (overlapStart.isAfter(overlapEnd) || overlapStart.isEqual(overlapEnd)) {</span>
<span class="nc" id="L313">            return 0.0;</span>
        }
        
<span class="fc" id="L316">        Duration overlapDuration = Duration.between(overlapStart, overlapEnd);</span>
<span class="fc" id="L317">        Duration totalDuration = duration1.plus(duration2);</span>
        
<span class="fc" id="L319">        return (double) overlapDuration.toMinutes() / totalDuration.toMinutes();</span>
    }

    private static LocalDateTime max(LocalDateTime dateTime1, LocalDateTime dateTime2) {
<span class="pc bpc" id="L323" title="1 of 2 branches missed.">        return dateTime1.isAfter(dateTime2) ? dateTime1 : dateTime2;</span>
    }

    private static LocalDateTime min(LocalDateTime dateTime1, LocalDateTime dateTime2) {
<span class="pc bpc" id="L327" title="1 of 2 branches missed.">        return dateTime1.isBefore(dateTime2) ? dateTime1 : dateTime2;</span>
    }

    public static double calculateResourceEfficiency(int scheduledAppointments, int totalCapacity) {
<span class="pc bpc" id="L331" title="1 of 2 branches missed.">        if (totalCapacity &lt;= 0) {</span>
<span class="nc" id="L332">            return 0.0;</span>
        }
<span class="fc" id="L334">        return (double) scheduledAppointments / totalCapacity;</span>
    }

    public static double calculateCostEfficiency(double totalScore, double totalCost) {
<span class="pc bpc" id="L338" title="1 of 2 branches missed.">        if (totalCost &lt;= 0) {</span>
<span class="nc" id="L339">            return totalScore;</span>
        }
<span class="fc" id="L341">        return totalScore / totalCost;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>